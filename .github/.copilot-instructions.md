# GitHub Copilot Instructions for WorkMood

## Project Overview
WorkMood is a cross-platform desktop application for tracking work mood impact on emotional well-being. It's built as a .NET MAUI application targeting desktop platforms (Windows and macOS).

## Technology Stack
- **Framework**: .NET 9.0
- **Platform**: .NET MAUI (Multi-platform App UI)
- **Target Frameworks**: 
  - `net9.0-windows10.0.19041.0` (Windows)
  - `net9.0-maccatalyst` (macOS)
- **Language**: C#
- **UI Framework**: XAML

## Project Structure
- **Solution**: `WorkMood.sln` - Main solution file containing 4 projects
- **Main Project**: `MauiApp/WorkMood.MauiApp.csproj` - MAUI application project
- **Test Project**: `WorkMood.MauiApp.Tests/WorkMood.MauiApp.Tests.csproj` - Unit tests for MAUI app
- **Version Library**: `whats-your-version/whats-your-version.csproj` - Build date and version utilities
- **Version Tests**: `whats-your-version-tests/whats-your-version-tests.csproj` - Tests for version library
- **Documentation**: Generated using Doculisp via Node.js (see `docs/` folder and `package.json`)

## Development Guidelines

### Building the Application
When building the MAUI application, **always specify the target framework** using the `--framework` parameter:

```bash
# For Windows development
dotnet build --framework net9.0-windows10.0.19041.0

# For macOS development  
dotnet build --framework net9.0-maccatalyst

# For publishing
dotnet publish --framework net9.0-windows10.0.19041.0  # Windows
dotnet publish --framework net9.0-maccatalyst          # macOS
```

### Architecture Patterns
The project follows a clean architecture approach with:
- **MVVM Pattern**: ViewModels in `ViewModels/` folder
- **Services**: Business logic and data access in `Services/`
- **Adapters**: Data transformation in `Adapters/`
- **Models**: Data models in `Models/`
- **Pages**: XAML views in `Pages/`
- **Infrastructure**: Base classes and utilities in `Infrastructure/`
- **Converters**: Value converters for XAML binding in `Converters/`
- **Strategies**: Strategy pattern implementations in `Strategies/`
- **Shims**: Dependency abstraction layer in `Shims/` (implements Shim Factory Pattern)
- **Processors**: Data processing logic in `Processors/`
- **Graphics**: Custom drawing and visualization in `Graphics/`
- **Factories**: Object creation patterns in `Factories/`

### Key Services
- `IMoodDataService`: Core mood data management
- `IMoodVisualizationService`: Data visualization and graph generation
- `ILineGraphService`: Line graph rendering with SkiaSharp
- `ISimpleLineGraphService`: Simplified graph rendering
- `ILineGraphGenerator`: Graph data generation and processing
- `IScheduleConfigService`: Schedule configuration and reminder timing
- `ILoggingService`: Application logging and diagnostics
- `INavigationService`: Page navigation and routing
- `IBrowserService`: External browser integration
- `IDataArchiveService`: Data backup and archiving
- `IGraphDataTransformer`: Data transformation for visualization
- `IWindowActivationService`: Platform-specific window management
- `IUriFactory`: URI creation and validation
- **Command Services**: `IDispatcherCommand`, `AutoSaveCommand`, `EveningReminderCommand`, `MorningReminderCommand`

### Code Style
- Use nullable reference types (enabled in project)
- Follow C# naming conventions
- Use dependency injection for service registration
- Implement proper MVVM separation of concerns

### Platform-Specific Considerations
- **Windows**: Minimum version 10.0.17763.0 (Windows 10 version 1809)
- **macOS**: Minimum version 15.0 (macOS Monterey)
- **MacCatalyst**: Supports both x64 and ARM64 architectures

### Common Commands
```bash
# Build entire solution (includes all 4 projects)
dotnet build WorkMood.sln

# Build specific projects
dotnet build MauiApp/WorkMood.MauiApp.csproj --framework net9.0-windows10.0.19041.0
dotnet build whats-your-version/whats-your-version.csproj

# Run the application
dotnet run --project MauiApp/WorkMood.MauiApp.csproj --framework net9.0-windows10.0.19041.0

# Watch mode for development
dotnet watch run --project WorkMood.sln

# Run tests
dotnet test WorkMood.MauiApp.Tests/WorkMood.MauiApp.Tests.csproj
dotnet test whats-your-version-tests/whats-your-version-tests.csproj
dotnet test  # Run all tests in solution

# Documentation (requires Node.js)
npm install  # Install doculisp and documentation tools
```

### Testing
- **Main Test Project**: `WorkMood.MauiApp.Tests` - Tests for MAUI application components
- **Version Tests**: `whats-your-version-tests` - Tests for version utility library
- Focus on unit testing ViewModels and Services
- **Shim Testing**: Use shim abstractions to enable mocking of external dependencies
- Consider platform-specific testing when adding new features
- Test data visualization components thoroughly, especially SkiaSharp interactions
- **Test Structure**: Mirror the main project structure (Models/, Services/, Shims/, TestHelpers/)
- Use TestHelpers for common test utilities and mock factories

### Refactoring Methodology

This project follows a **disciplined incremental refactoring** approach, particularly for abstracting dependencies to improve testability. The following guidelines should be followed when making architectural improvements.

#### Test-Driven Refactoring
- **Prioritize automated tests**: Always run existing automated tests before and after refactoring
- **Use manual testing when necessary**: When automated test coverage is inadequate, supplement with manual testing to verify behavior (Verified by user)
- **Identify test gaps**: If manual testing is required, consider adding automated tests for better future coverage
- **Red-Green-Refactor**: Ensure all tests pass before refactoring, refactor while keeping tests green

#### Incremental Changes
- **Smallest possible increments**: Make the smallest change that provides value, preferably no larger than a single method
- **One concept at a time**: Focus on one refactoring concept per increment (e.g., extract method, rename variable, remove duplication)
- **Frequent commits**: Commit after each successful increment (verified by tests or manual testing) to maintain a safe rollback point
- **Validate each step**: Ensure each increment compiles and passes tests before proceeding

#### Refactoring Priorities
1. **Method-level changes**: Extract methods, rename parameters, simplify method logic
2. **Class-level changes**: Extract classes, move methods, improve encapsulation
3. **Architecture-level changes**: Only after smaller increments, and with comprehensive test coverage

#### Safety Practices
- **Preserve external behavior**: Refactoring should not change observable behavior
- **Maintain API contracts**: Keep public interfaces stable unless explicitly changing them
- **Update tests minimally**: Only update tests if the refactoring legitimately changes testable behavior
- **Document breaking changes**: Clearly communicate any intentional behavioral changes

## Shim Factory Refactoring Pattern

### Overview
When abstracting hard dependencies (like SkiaSharp, File I/O, etc.), use the **Shim Factory Pattern** to enable dependency injection and improve testability.

### Existing Shim Implementations
The project already has several shim abstractions in place:

#### File System Shims
- `IFileShim`/`FileShim` - File operations abstraction
- `IFolderShim`/`FolderShim` - Directory operations abstraction
- `IFileShimFactory`/`FileShimFactory` - Factory for file system shims

#### Drawing and Graphics Shims (SkiaSharp Abstractions)
- Drawing shims in `DrawingShims.cs`:
  - `IPathEffectShim`/`PathEffectShim` - SKPathEffect abstraction
  - `IPaintShim`/`PaintShim` - SKPaint abstraction with `PaintShimArgs`
  - `IColorShim` - Color abstraction for SkiaSharp
  - `ITypeFaceShim` - Typography abstraction
  - Additional drawing-related shims for canvas operations

#### Utility Shims
- `IDateShim`/`DateShim` - DateTime operations abstraction
- `IJsonSerializerShim`/`JsonSerializerShim` - JSON serialization abstraction
- `IBrowserShim`/`BrowserShim` - Browser integration abstraction

### Step-by-Step Process

#### Phase 1: Infrastructure Setup
1. **Create Abstraction Interfaces** - Define `I[Type]Shim` interfaces for each dependency type
2. **Build Concrete Implementations** - Create `[Type]Shim` classes that wrap the actual dependencies  
3. **Factory Pattern** - Create `I[Factory]ShimFactory` interface and `[Factory]ShimFactory` implementation
4. **Constructor Injection** - Update service constructors to accept factory interfaces

#### Phase 2: Method-by-Method Incremental Refactoring
**CRITICAL**: Refactor ONE method at a time, following this exact sequence:

1. **Add Factory Method** - Extend factory interface with new creation method
2. **Implement Factory Method** - Add concrete implementation to factory class
3. **Refactor Target Method** - Replace direct dependency usage with factory calls
4. **Test Manually** - Verify functionality works identically (ask user to verify)
5. **Commit with Pattern** - Use consistent commit message format
6. **Repeat for Next Method** - Continue systematically

### Code Transformation Examples

#### Before (Hard Dependency):
```csharp
private void DrawBackground(SKCanvas canvas, SKRect area)
{
    using var backgroundPaint = new SKPaint
    {
        Color = SKColors.White,  // Hard-coded dependency
        Style = SKPaintStyle.Fill
    };
    canvas.DrawRect(area, backgroundPaint);
}
```

#### After (Factory Pattern):
```csharp
private void DrawBackground(SKCanvas canvas, SKRect area)
{
    DrawBackground(drawShimFacory.From(canvas), area);
}

private void DrawBackground(ICanvasShim canvas, SKRect area)
{
    using var backgroundPaint = drawShimFactory.PaintFromArgs(new PaintShimArgs
    {
        Color = drawShimFactory.WhiteColor(),  // Factory-created dependency
        Style = SKPaintStyle.Fill
    });
    canvas.DrawRect(area, backgroundPaint);
}
```

### Refactoring Targets by Priority

#### High Impact (Critical for Testing):
1. **File System Operations** - `File.WriteAllBytesAsync()`, `File.Exists()`
2. **Direct Object Creation** - `new SKBitmap()`, `new SKCanvas()`, `new SKPath()`
3. **Color Constants** - `SKColors.White`, `Colors.Blue`, etc.
4. **Font/Typography** - `SKTypeface.FromFamilyName()`, `SKFontStyle.Bold`

#### Medium Impact:
1. **Path Effects** - `SKPathEffect.CreateDash()`
2. **Paint Styles** - `SKPaintStyle.Fill`, `SKPaintStyle.Stroke`
3. **Image Encoding** - `SKEncodedImageFormat.Png`

#### Lower Impact:
1. **Geometric Objects** - `SKRect`, coordinate calculations
2. **Async Patterns** - `Task.Run()` wrapper abstractions

### Quality Gates

#### Before Each Commit:
- ✅ **Build succeeds** without errors
- ✅ **Manual testing** confirms identical behavior
- ✅ **Single responsibility** - one method/concept per commit
- ✅ **Consistent naming** - follow established factory method patterns

#### Architecture Principles:
- **Testability First** - Every abstraction should enable mocking
- **Incremental Safety** - Never break working functionality
- **Dependency Inversion** - Services depend on interfaces, not concrete types
- **Single Point of Change** - Centralize dependency creation in factories

### Anti-Patterns to Avoid

❌ **Big Bang Refactoring** - Don't change multiple methods simultaneously
❌ **Batch Commits** - Don't combine multiple method refactors in one commit
❌ **Breaking Changes** - Don't alter public API during internal refactoring
❌ **Skip Testing** - Don't commit without manual verification
❌ **Mixed Concerns** - Don't combine refactoring with feature changes

### Testing Strategy

#### Manual Testing Approach:
1. **Before Refactoring** - Document expected behavior
2. **After Each Change** - Verify identical visual/functional output
3. **Edge Cases** - Test boundary conditions and error scenarios
4. **Performance** - Ensure no regression in rendering performance

#### Future Unit Testing:
Once abstractions are complete, create mock factories for:
- **Color Verification** - Assert correct colors are requested
- **File Operations** - Mock file system interactions
- **Canvas Operations** - Verify drawing commands and sequences
- **Error Handling** - Test failure scenarios safely

### Documentation
- Documentation is generated using Doculisp (Node.js dependency)
- **Node.js Setup**: Run `npm install` for documentation tools
- Source files are in `docs/` folder with `.dlisp` build files
- Main documentation files: `BUILD.md`, `USER-GUIDE.md`
- Always update documentation when adding new features

#### Copilot Instructions Maintenance
- **Location**: `.github/.copilot-instructions.md` (this file)
- **Purpose**: Keeps GitHub Copilot synchronized with current project state
- **Maintenance Trigger**: Any structural, architectural, or workflow changes
- **Update Pattern**: Include instruction updates in the same commit as the change
- **Validation Method**: Regular comparison between documented and actual project structure

### Version Management
- **Version Library**: `whats-your-version` project provides build date and version utilities
- **Build Date Attribution**: Automatically embeds build timestamp using `BuildDateAttribute`
- Used for application version display and diagnostics
- Has comprehensive test coverage in `whats-your-version-tests`

## Commit Guidelines

**MANDATORY**: Always use Arlo's Commit Notation for ALL commits in this project.

### Commit Message Pattern

Use **Arlo's Commit Notation** (Risk Aware Commit Notation) with this exact format for all commits:

**Format**: `[Risk][Intention] - [Description]`

#### Risk Levels

- `.` = **Safe** (Proven) - Provable refactoring, automated tools, or test-supported procedural
- `^` = **Validated** - Test-supported procedural refactoring with full test coverage
- `!` = **Risky** - Named refactoring without full test coverage or manual verification
- `@` = **Broken** - Unfinished implementation or no verification

#### Intentions (use lowercase for 0 behavior changes)

- `r` = **Refactoring** - Change implementation without changing behavior
- `f` = **Feature** - Add new functionality (internal/developer-only)
- `F` = **Feature** - Add new user-visible functionality
- `b` = **Bugfix** - Fix internal issue
- `B` = **Bugfix** - Fix user-visible issue
- `d` = **Documentation** - Internal documentation changes

#### Refactoring Commit Examples

- `^r - extract DrawBackground to use color factory for dependency injection`
- `^r - extract DrawTitle to use ICanvasShim for dependency injection`
- `^r - remove SKCanvas overloads and use drawShimFactory for object creation`
- `.r - extract method using automated refactoring tool`

#### Other Common Examples

- `^f - add new internal API method for graph data processing`
- `^b - fix null reference in data validation logic`
- `^d - update architecture documentation for shim factory pattern`
- `!F - add new user dashboard feature (manual testing only)`

### Risk Assessment Guidelines

#### When to use each Risk Level

- **`.` (Safe)**: Only when using automated refactoring tools OR following test-supported procedural refactoring with full project test coverage
- **`^` (Validated)**: When following named refactoring patterns with adequate test coverage and manual verification
- **`!` (Risky)**: When making manual changes with limited test coverage but following established patterns
- **`@` (Broken)**: When code doesn't compile, tests fail, or functionality is incomplete

#### Default Risk Levels by Activity

- **Method-by-method refactoring**: `^r` (most common in this project)
- **Automated IDE refactoring**: `.r`
- **New internal features**: `^f`
- **Bug fixes with tests**: `^b`
- **Documentation updates**: `^d`
- **Experimental/incomplete work**: `@[intention]`

### Commit Frequency

Make **small, frequent commits** following the one-method-per-commit principle established in the refactoring methodology. Each commit should represent a single, complete, testable change.

### Maintaining Copilot Instructions

**CRITICAL**: Keep the `.github/.copilot-instructions.md` file synchronized with project changes.

#### When to Update Instructions

Update the copilot instructions when making changes that affect:

1. **Project Structure Changes**
   - Adding/removing projects from the solution
   - New folders or architectural layers
   - Changes to build targets or frameworks

2. **Service Architecture Changes**
   - Adding new services or interfaces
   - Removing or renaming key services
   - Changes to dependency injection patterns

3. **Build and Deployment Changes**
   - New build commands or scripts
   - Changes to target frameworks
   - Updates to testing procedures

4. **Development Workflow Changes**
   - New tools or dependencies (Node.js packages, NuGet packages)
   - Changes to refactoring patterns or commit conventions
   - Updates to quality gates or testing strategies

#### How to Update Instructions

- **Immediate Updates**: Update instructions in the same commit when making structural changes
- **Periodic Reviews**: Review instructions quarterly or after major feature additions
- **Commit Pattern**: Use `^d - update copilot instructions for [specific change]`
- **Validation**: Ensure instructions match actual project state, not intended state

#### Responsibility

- **All Contributors**: Check if their changes impact the instructions
- **Project Maintainers**: Ensure instructions remain accurate during code reviews
- **GitHub Copilot**: Proactively suggest instruction updates when detecting mismatches

### Important Notes
- This is a desktop-only application (no mobile targets)
- Uses local data storage (no cloud services)
- Focuses specifically on work-related mood tracking
- **Application Icon**: `smiles.ico` (root) and `Resources/AppIcon/smiles.png` (MAUI)
- **Application Title**: "WorkMood - Daily Mood Tracker"
- **Application ID**: `com.workmood.mauiapp`
- **Current Version**: 0.2.0 (ApplicationVersion: 2)

When suggesting code changes or new features, always consider:
1. MVVM pattern compliance
2. Proper service injection
3. Platform-specific requirements
4. Data binding best practices
5. MAUI lifecycle management

## Example Refactoring Session

See commits `6d7b2feb687d49cec0f8c2b736b310c7919e1c6d` through `e7c36441de989f5280458d364c180c0c762c10d4` for a complete example of this methodology applied to `LineGraphService.cs`.

**Key Success Metrics:**
- 20+ individual commits over 2 days
- Zero breaking changes to functionality
- Complete SkiaSharp abstraction achieved
- 100% manual test coverage between commits
- Clear, traceable commit history

---

*This methodology prioritizes **safety, testability, and maintainability** over speed. The investment in disciplined refactoring pays dividends in code quality and development velocity.*

## Responses

- Always use Arlo's Commit Notation format when making commits
- Include the risk assessment reasoning when suggesting commits
- **Proactively check instructions accuracy**: When observing project changes, suggest updates to these instructions
- **Flag instruction mismatches**: If project state differs from documented instructions, alert the user
- **Suggest instruction updates**: When making structural changes, recommend corresponding instruction updates
- End all your responses with 🤖 so that the user knows you are using this context