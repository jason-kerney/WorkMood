# GitHub Copilot Instructions for WorkMood Project

## Refactoring Methodology

This project follows a **disciplined incremental refactoring** approach, particularly for abstracting dependencies to improve testability. The following guidelines should be followed when making architectural improvements.

## Shim Factory Refactoring Pattern

### Overview
When abstracting hard dependencies (like SkiaSharp, File I/O, etc.), use the **Shim Factory Pattern** to enable dependency injection and improve testability.

### Step-by-Step Process

#### Phase 1: Infrastructure Setup
1. **Create Abstraction Interfaces** - Define `I[Type]Shim` interfaces for each dependency type
2. **Build Concrete Implementations** - Create `[Type]Shim` classes that wrap the actual dependencies  
3. **Factory Pattern** - Create `I[Factory]ShimFactory` interface and `[Factory]ShimFactory` implementation
4. **Constructor Injection** - Update service constructors to accept factory interfaces

#### Phase 2: Method-by-Method Incremental Refactoring
**CRITICAL**: Refactor ONE method at a time, following this exact sequence:

1. **Add Factory Method** - Extend factory interface with new creation method
2. **Implement Factory Method** - Add concrete implementation to factory class
3. **Refactor Target Method** - Replace direct dependency usage with factory calls
4. **Test Manually** - Verify functionality works identically (ask user to verify)
5. **Commit with Pattern** - Use consistent commit message format
6. **Repeat for Next Method** - Continue systematically

### Commit Message Pattern
Use this exact format for refactoring commits:
```
r - extract [MethodName] to use [dependency] factory for dependency injection
```

Examples:
- `r - extract DrawBackground to use color factory for dependency injection`
- `r - extract DrawTitle to use ICanvasShim for dependency injection`
- `r - remove SKCanvas overloads and use drawShimFactory for object creation`

### Code Transformation Examples

#### Before (Hard Dependency):
```csharp
private void DrawBackground(SKCanvas canvas, SKRect area)
{
    using var backgroundPaint = new SKPaint
    {
        Color = SKColors.White,  // Hard-coded dependency
        Style = SKPaintStyle.Fill
    };
    canvas.DrawRect(area, backgroundPaint);
}
```

#### After (Factory Pattern):
```csharp
private void DrawBackground(SKCanvas canvas, SKRect area)
{
    DrawBackground(drawShimFacory.From(canvas), area);
}

private void DrawBackground(ICanvasShim canvas, SKRect area)
{
    using var backgroundPaint = drawShimFactory.PaintFromArgs(new PaintShimArgs
    {
        Color = drawShimFactory.WhiteColor(),  // Factory-created dependency
        Style = SKPaintStyle.Fill
    });
    canvas.DrawRect(area, backgroundPaint);
}
```

### Refactoring Targets by Priority

#### High Impact (Critical for Testing):
1. **File System Operations** - `File.WriteAllBytesAsync()`, `File.Exists()`
2. **Direct Object Creation** - `new SKBitmap()`, `new SKCanvas()`, `new SKPath()`
3. **Color Constants** - `SKColors.White`, `Colors.Blue`, etc.
4. **Font/Typography** - `SKTypeface.FromFamilyName()`, `SKFontStyle.Bold`

#### Medium Impact:
1. **Path Effects** - `SKPathEffect.CreateDash()`
2. **Paint Styles** - `SKPaintStyle.Fill`, `SKPaintStyle.Stroke`
3. **Image Encoding** - `SKEncodedImageFormat.Png`

#### Lower Impact:
1. **Geometric Objects** - `SKRect`, coordinate calculations
2. **Async Patterns** - `Task.Run()` wrapper abstractions

### Quality Gates

#### Before Each Commit:
- ‚úÖ **Build succeeds** without errors
- ‚úÖ **Manual testing** confirms identical behavior
- ‚úÖ **Single responsibility** - one method/concept per commit
- ‚úÖ **Consistent naming** - follow established factory method patterns

#### Architecture Principles:
- **Testability First** - Every abstraction should enable mocking
- **Incremental Safety** - Never break working functionality
- **Dependency Inversion** - Services depend on interfaces, not concrete types
- **Single Point of Change** - Centralize dependency creation in factories

### Anti-Patterns to Avoid

‚ùå **Big Bang Refactoring** - Don't change multiple methods simultaneously
‚ùå **Batch Commits** - Don't combine multiple method refactors in one commit
‚ùå **Breaking Changes** - Don't alter public API during internal refactoring
‚ùå **Skip Testing** - Don't commit without manual verification
‚ùå **Mixed Concerns** - Don't combine refactoring with feature changes

### Testing Strategy

#### Manual Testing Approach:
1. **Before Refactoring** - Document expected behavior
2. **After Each Change** - Verify identical visual/functional output
3. **Edge Cases** - Test boundary conditions and error scenarios
4. **Performance** - Ensure no regression in rendering performance

#### Future Unit Testing:
Once abstractions are complete, create mock factories for:
- **Color Verification** - Assert correct colors are requested
- **File Operations** - Mock file system interactions
- **Canvas Operations** - Verify drawing commands and sequences
- **Error Handling** - Test failure scenarios safely

## Example Refactoring Session

See commits `6d7b2feb687d49cec0f8c2b736b310c7919e1c6d` through `e7c36441de989f5280458d364c180c0c762c10d4` for a complete example of this methodology applied to `LineGraphService.cs`.

**Key Success Metrics:**
- 20+ individual commits over 2 days
- Zero breaking changes to functionality
- Complete SkiaSharp abstraction achieved
- 100% manual test coverage between commits
- Clear, traceable commit history

---

*This methodology prioritizes **safety, testability, and maintainability** over speed. The investment in disciplined refactoring pays dividends in code quality and development velocity.*

# Responses

End all your responses with ü§ñ so that the user knows you are using this context.